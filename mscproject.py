# -*- coding: utf-8 -*-
"""MScProject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r9MCGI-kvmosw7yvhy3ba701Z_vJrHQR
"""

import numpy as np
import pandas as pd
import seaborn as sns
import plotly.express as px
import plotly.subplots as sp
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from sklearn.preprocessing import LabelEncoder

from google.colab import drive
drive.mount('/content/drive')

EC=pd.read_csv('/content/drive/MyDrive/MScProject/online_shoppers_intention.csv')
EC.head()

EC.info()

numerical_variables = EC[[ 'Administrative_Duration','Informational_Duration','ProductRelated_Duration','BounceRates','ExitRates','PageValues','SpecialDay']]

numerical_variables.describe()

categorical_variables = EC[['Month', 'OperatingSystems', 'Browser','Region','TrafficType','VisitorType','Weekend','Revenue']]

categorical_variables.nunique()

variable=['Weekend','Revenue']
for col in variable:
    encoder = LabelEncoder()
    encoder.fit(EC[col])
    print('Column:', col)
    print('Original categories:', encoder.classes_)
    print('Encoded values:', encoder.transform(encoder.classes_))
    print('\n')
    EC[col] = encoder.fit_transform(EC[col])

EC['Month'] = EC['Month'].map({'Feb': 2, 'Mar': 3, 'May': 5,'June':6,'Jul':7,'Aug':8,'Sep':9,'Oct':10,'Nov':11,'Dec':12})

EC.duplicated().value_counts()

EC.drop_duplicates(inplace=True)

MMC = ['Administrative_Duration','Informational_Duration','ProductRelated_Duration','BounceRates','ExitRates','PageValues','SpecialDay']

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
EC[MMC] = scaler.fit_transform(EC[MMC])

fig = px.histogram(EC, x='Revenue', color='Revenue', title='Revenue Class Distribution',
                   labels={'Revenue': 'Revenue', 'count': 'Count'}, color_discrete_map={'0': 'navy', '1': 'orange'})

fig.update_layout(
    xaxis_title='Revenue',
    yaxis_title='Count',
    showlegend=True,
    height=500,
    width=500,
    bargap=0.1,
)
fig.show()

#fig = px.histogram(EC, x='PageValues', color='Revenue', histnorm='probability density', marginal='violin')

plt.figure(figsize=(8, 6))
sns.kdeplot(data=EC, x='PageValues', hue='Revenue', fill=True, common_norm=False)
plt.title('Density Plot for Page Value by Revenue')
plt.xlabel('Page Value')
plt.ylabel('Density')

plt.grid(True)
plt.show()

correlation_matrix = EC.corr()

# Create a correlation heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
plt.title('Correlation Heatmap')
plt.show()

"revenue_comparison = EC.groupby('TrafficType')['Revenue'].agg(['sum']).reset_index()

fig = px.line(revenue_comparison, x='TrafficType', y='sum', markers=True, line_shape='linear',
              labels={'TrafficType': 'Traffic Type', 'sum': 'Total Revenue'})

fig.update_layout(
    title='Total Revenue by Traffic Type',
    xaxis_title='Traffic Type',
    yaxis_title='Total Revenue',
    xaxis=dict(tickangle=45),
    height=500
)

fig.show()

traffic_types = [1, 2,3,5,8]
visitor = ['VisitorType']

fig = sp.make_subplots(rows=1, cols=len(traffic_types), subplot_titles=[f'Traffic Type {t}' for t in traffic_types])

bar_color = 'teal'

for i, traffic_type in enumerate(traffic_types, start=1):
    traffic_type_data = EC[EC['TrafficType'] == traffic_type]

    for j, variable in enumerate(visitor, start=1):
        fig.add_trace(go.Bar(x=traffic_type_data[variable].value_counts().index,
                             y=traffic_type_data[variable].value_counts().values,
                             name=f'{variable} for Traffic Type {traffic_type}',
                             marker_color=bar_color),row=1, col=i)

fig.update_layout(title_text='Visitors Distribution for Traffic Types',
                  xaxis=dict(title='Visitors type'),
                  yaxis=dict(title='Count'),
                  showlegend=False)

fig.show()

traffic_types = [1,2, 3]

behavioral_variable = 'PageValues'

plt.figure(figsize=(18, 6))

for i, traffic_type in enumerate(traffic_types, start=1):
    traffic_type_data = EC[EC['TrafficType'] == traffic_type]
    plt.subplot(1, len(traffic_types), i)
    sns.boxplot(data=traffic_type_data, x=behavioral_variable)
    plt.title(f'{behavioral_variable} Distribution for Traffic Type {traffic_type}')
    plt.xlabel(behavioral_variable)

plt.tight_layout()
plt.show()

N=len(EC)
colors = np.random.rand(N)
plt.scatter(EC['PageValues'], EC['BounceRates'],c=colors)
plt.title('Page Values vs. Bounce Rates')
plt.xlabel('Page Values')
plt.ylabel('Bounce Rates')
plt.show()

sns.set(style="whitegrid")

plt.figure(figsize=(12, 6))
sns.countplot(x='Month', hue='Revenue', data=EC, palette='viridis')

plt.title('Revenue Distribution Across Months')
plt.xlabel('Month')
plt.ylabel('Count')
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Assuming 'EC' is your DataFrame with 'VisitorType' and 'revenue' columns

# Filter the DataFrame for instances where revenue is positive
revenue_generated_data = EC[EC['Revenue'] == 1]

# Set the style for the plot
sns.set(style="whitegrid")

# Create a count plot for revenue distribution across visitor types for revenue-generated instances
plt.figure(figsize=(10, 6))
sns.countplot(x='VisitorType', data=revenue_generated_data, palette='viridis')

# Set labels and title
plt.title('Visitor Types Generating Revenue')
plt.xlabel('Visitor Type')
plt.ylabel('Count')

# Show the plot
plt.show()

import pandas as pd
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, VotingClassifier
from xgboost import XGBClassifier
from lightgbm import LGBMClassifier
from catboost import CatBoostClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score

pip install catboost

EC.head()

# Initialize the LabelEncoder
label_encoder = LabelEncoder()
#encoder.fit(df['category'])
# Fit and transform the categorical variable
EC['VisitorType'] = label_encoder.fit_transform(EC['VisitorType'])

EC.head()

correlation_matrix = EC.corr()

mask = np.triu(np.ones_like(correlation_matrix, dtype=bool))

# Create a correlation heatmap with masked upper triangle
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, mask=mask, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
plt.title('Correlation Heatmap ')
plt.show()